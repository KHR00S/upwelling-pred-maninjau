knitr::opts_chunk$set(echo = TRUE)
# Load and prepare the dataset
df <- read.delim("D:\MODELING_ML\GIT\upwelling-pred-maninjau\data\DATA TRAIN.csv", sep = ";")
# Load and prepare the dataset
df <- read.delim("D:\MODELING_ML\GIT\upwelling-pred-maninjau\data\DATA TRAIN.csv", sep = ",")
# Load and prepare the dataset
df <- read.delim("D:/MODELING_ML/GIT/upwelling-pred-maninjau/data/DATA TRAIN.csv", sep = ";")
df$Date <- as.Date(df$Date, format = "%d/%m/%Y")
# Convert TS, PRECTOTCORR, and WS10M to numeric (handle comma decimals)
df$TS <- as.numeric(gsub(",", ".", df$TS))
df$PRECTOTCORR <- as.numeric(gsub(",", ".", df$PRECTOTCORR))
df$WS10M <- as.numeric(gsub(",", ".", df$WS10M))
# Check the first few rows to verify conversion
head(df)
library(dplyr)
library(ggplot2)
library(forecast)
# Simpan nilai minimum dan maksimum sebelum normalisasi untuk TS, PRECTOTCORR, dan WS10M
min_values <- sapply(df[, c("TS", "PRECTOTCORR", "WS10M")], min)
max_values <- sapply(df[, c("TS", "PRECTOTCORR", "WS10M")], max)
# Print nilai minimum dan maksimum
print("Nilai minimum:")
print(min_values)
print("Nilai maksimum:")
print(max_values)
# Fungsi untuk normalisasi menggunakan Min-Max Scaling
min_max_normalize <- function(x) {
return((x - min(x)) / (max(x) - min(x)))
}
# Lakukan normalisasi pada kolom TS, PRECTOTCORR, dan WS10M
df_normalized <- df %>%
mutate(
TS = min_max_normalize(TS),
PRECTOTCORR = min_max_normalize(PRECTOTCORR),
WS10M = min_max_normalize(WS10M)
)
# Print data setelah normalisasi
head(df_normalized)
# Konversi ke time series dengan frekuensi harian (365 hari dalam setahun)
data_ts <- ts(df_normalized[, c("TS", "PRECTOTCORR", "WS10M")], start = c(2016, 07, 20), frequency = 365)
# Plot time series dengan autoplot
autoplot(data_ts, facets = TRUE) +
labs(title = "Normalized TS, PRECTOTCORR, and WS10M Time Series", x = "Time", y = "Normalized Value") +
theme_minimal()
# Split data into training and test sets
n_train <- as.integer(0.8*nrow(data_ts))
train_data <- head(data_ts, n_train)
test_data <- tail(data_ts, -n_train)
nrow(df)
#Save the predicted values to a CSV file
#write.csv(test_data, "test_data.csv", row.names = FALSE)
library(vars)
VARselect(train_data, lag.max = 15, type = "const", season = 365)
library(vars)
VARselect(train_data, lag.max = 15, type = "const")
VP5C <- vars::VAR(train_data, p=5, type = "const")
# Forecasting
forecast_VP5C <- forecast(VP5C, h = 968)
forecast_VP5C_df <- data.frame(
TS = forecast_VP5C$forecast$TS,
PRECTOTCORR = forecast_VP5C$forecast$PRECTOTCORR,
WS10M = forecast_VP5C$forecast$WS10M
)
# plot
train_data[,"TS"] %>%
autoplot(main = "TS") +
autolayer(test_data[,"TS"], series = "Test Data") +
autolayer(forecast_VP5C$forecast$TS$mean, series = "Forecast")
train_data[,"PRECTOTCORR"] %>%
autoplot(main = "PRECTOTCORR") +
autolayer(test_data[,"PRECTOTCORR"], series = "Test Data") +
autolayer(forecast_VP5C$forecast$PRECTOTCORR$mean, series = "Forecast")
train_data[,"WS10M"] %>%
autoplot(main = "WS10M") +
autolayer(test_data[,"WS10M"], series = "Test Data") +
autolayer(forecast_VP5C$forecast$WS10M$mean, series = "Forecast")
VP5C <- vars::VAR(train_data, p=5, season = 365, type = "const")
# Forecasting
forecast_VP5C <- forecast(VP5C, h = 968)
forecast_VP5C_df <- data.frame(
TS = forecast_VP5C$forecast$TS,
PRECTOTCORR = forecast_VP5C$forecast$PRECTOTCORR,
WS10M = forecast_VP5C$forecast$WS10M
)
# plot
train_data[,"TS"] %>%
autoplot(main = "TS") +
autolayer(test_data[,"TS"], series = "Test Data") +
autolayer(forecast_VP5C$forecast$TS$mean, series = "Forecast")
train_data[,"PRECTOTCORR"] %>%
autoplot(main = "PRECTOTCORR") +
autolayer(test_data[,"PRECTOTCORR"], series = "Test Data") +
autolayer(forecast_VP5C$forecast$PRECTOTCORR$mean, series = "Forecast")
train_data[,"WS10M"] %>%
autoplot(main = "WS10M") +
autolayer(test_data[,"WS10M"], series = "Test Data") +
autolayer(forecast_VP5C$forecast$WS10M$mean, series = "Forecast")
